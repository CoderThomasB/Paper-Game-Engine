<!DOCTYPE html>
<html>

<body>
	<canvas id="match" style="width: 500px; border: 1px solid; margin: auto; float: right;" width="500"
		height="500"></canvas>
	<script type="text/javascript" src="main.js"></script>
	<script>
		class custom_practical extends base_practical {
			/**
			 * 
			 * @param {base_practical} practical_Type 
			 * @param {render_component[]} visible_list 
			 * @param {Number} creation_interval
			 */
			constructor(practical_Type, visible_list, creation_interval = 0) {
				super(practical_Type, visible_list, creation_interval)

				this.velocity = new Vector2(Math.random() - 0.5, 1) // meshed in units per second
				this.velocity.normalize().multiplyScalar(2)

				this.max_existence_time = 4000

				this.attached_render_component.colour = `rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`
			}
		}

		class test extends visible {
			keyframe_animation() {
				// these animations are vary exaggerated you would want to use apply_animation not animatable render component because it dons not change the object location

				var x_min = 1
				var y_min = 1
				var x_max = 9
				var y_max = 9
				var a = new animation([
					new keyframe(0, "offset.x", x_min, keyframe_types.liner),
					new keyframe(0, "offset.y", y_min, keyframe_types.liner),

					new keyframe(250, "offset.x", x_max, keyframe_types.liner),
					new keyframe(250, "offset.y", y_min, keyframe_types.liner),

					new keyframe(500, "offset.x", x_max, keyframe_types.liner),
					new keyframe(500, "offset.y", y_max, keyframe_types.liner),

					new keyframe(750, "offset.x", x_min, keyframe_types.liner),
					new keyframe(750, "offset.y", y_max, keyframe_types.liner),

					new keyframe(1000, "offset.x", x_min, keyframe_types.liner),
					new keyframe(1000, "offset.y", y_min, keyframe_types.liner),
				], 0, 1000)
				this.location.x = 0
				this.location.y = 0
				this.visible[0] = new animatable_keyframe_render_component(new rectangle(new Vector2(1, 1)), "#36fffc", a)
				this.visible[0].play()
			}
			function_animation() {
				// these animations are vary exaggerated you would want to use apply_animation not animatable render component because it dons not change the object location
				var a = (the_render_component) => {
					let size = 2
					the_render_component.offset.x = size * Math.sin((the_render_component.now / the_render_component.end) * Math.PI * 2 * 2)
					the_render_component.offset.y = size * Math.cos((the_render_component.now / the_render_component.end) * Math.PI * 2 * 2)
				}
				var stop = () => { this.now = this.start }
				this.visible[0] = new animatable_function_render_component(new rectangle(new Vector2(1, 1)), "#36fffc", a, 0, 2000)
				this.visible[0].play()
				this.location.x = 5
				this.location.y = 5
			}
			practicals(creation_interval = 50) {
				if (this.practical_emitter !== undefined) {
					throw new Error("Practical Emitter is already defined and trying to add another would be a bad idea!")
				}
				this.location.x = 5
				this.location.y = 0
				this.visible[0] = new render_component(new rectangle(new Vector2(1, 1)), "hsl(0, 0%, 80%)")
				this.practical_emitter = new practical_emitter(custom_practical, this.visible, creation_interval)
			}
		}

		The_world = new world()
		The_camera = new camera(The_world, new Vector2(0, 0), document.getElementsByTagName("canvas")[0], new Vector2(11, 11))

		The_Test = new test(The_world, new Vector2(1, 1))

		function draw() {
			requestAnimationFrame(draw)
			The_camera.draw()
		}
		draw()
	</script>
</body>

</html>